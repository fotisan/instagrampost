<script>
(() => {
  const viewport = document.getElementById("viewport");
  const feed = document.getElementById("feed");
  const posts = [...feed.querySelectorAll(".post")];
  const arts  = [...feed.querySelectorAll(".art")];
  const chip = document.getElementById("chip");
  const bar = document.getElementById("bar");
  const clock = document.getElementById("clock");
  const hand = document.getElementById("ghostHand");

  // --- SVG FACTORY & BASICS (Ίδια με πριν) ---
  function svg(name){
    const baseDefs = `
      <defs>
        <filter id="glow"><feGaussianBlur stdDeviation="6" result="b"/><feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge></filter>
        <linearGradient id="gA" x1="0" y1="0" x2="1" y2="1"><stop offset="0" stop-color="#ccff00"/><stop offset="1" stop-color="#99cc00"/></linearGradient>
      </defs>`;
    const shell = (inner) => `<svg viewBox="0 0 720 520" class="svg" xmlns="http://www.w3.org/2000/svg">${baseDefs}<g filter="url(#glow)"><rect x="70" y="70" rx="34" width="580" height="380" fill="rgba(255,255,255,.03)" stroke="rgba(255,255,255,.1)"/>${inner}</g></svg>`;
    
    // (Τα SVGs μένουν τα ίδια, δεν τα ξαναγράφω για οικονομία χώρου - κράτα τα δικά σου)
    if (name === "intro") return shell(`<path d="M130 160 h420" stroke="#333" stroke-width="2"/><path d="M130 220 h260" stroke="#333" stroke-width="2"/><circle cx="560" cy="220" r="8" fill="url(#gA)"/>`);
    if (name === "intent") return shell(`<rect x="120" y="140" rx="8" width="480" height="60" stroke="#333" fill="none"/><text x="140" y="175" fill="#666" font-family="monospace" font-size="14">search: "austin therapy"</text><rect x="120" y="220" rx="8" width="480" height="60" stroke="#333" fill="none"/><path d="M540 170 L560 190 L540 210" stroke="url(#gA)" stroke-width="2" fill="none"/>`);
    if (name === "services") return shell(`<rect x="120" y="150" width="140" height="180" stroke="#333" fill="none"/><rect x="280" y="150" width="140" height="180" stroke="#333" fill="none"/><rect x="440" y="150" width="140" height="180" stroke="url(#gA)" stroke-width="2" fill="none"/>`);
    if (name === "faq") return shell(`<rect x="120" y="160" width="480" height="40" stroke="#333" fill="none"/><circle cx="570" cy="180" r="4" fill="#666"/><rect x="120" y="220" width="480" height="40" stroke="#333" fill="none"/><circle cx="570" cy="240" r="4" fill="url(#gA)"/>`);
    if (name === "quietseo") return shell(`<text x="130" y="180" fill="#fff" font-size="24" font-weight="bold">H1 Title</text><path d="M130 200 h400" stroke="#333" stroke-width="1"/><text x="130" y="260" fill="#666" font-size="18">H2 (Keywords)</text><path d="M130 280 h300" stroke="url(#gA)" stroke-width="2"/>`);
    if (name === "proof") return shell(`<rect x="120" y="180" width="480" height="100" stroke="#333" fill="none"/><path d="M150 230 h50" stroke="url(#gA)" stroke-width="4"/><path d="M220 230 h50" stroke="#333" stroke-width="4"/><path d="M290 230 h50" stroke="#333" stroke-width="4"/>`);
    if (name === "cta") return shell(`<rect x="200" y="200" rx="100" width="320" height="80" stroke="url(#gA)" stroke-width="2" fill="none"/><text x="360" y="245" text-anchor="middle" fill="#fff" font-size="14" letter-spacing="2">BOOK NOW</text>`);
    return shell(`<text x="360" y="260" text-anchor="middle" fill="url(#gA)" font-size="40" font-weight="bold">SEND</text>`);
  }
  arts.forEach(a => a.innerHTML = svg(a.dataset.art));

  function updateClock(){
    const d = new Date();
    clock.textContent = `${String(d.getHours()).padStart(2,"0")}:${String(d.getMinutes()).padStart(2,"0")}`;
  }
  updateClock();

  function updateUI(){
    const max = Math.max(1, viewport.scrollHeight - viewport.clientHeight);
    const prog = Math.max(0, Math.min(1, viewport.scrollTop / max));
    bar.style.transform = `scaleY(${prog})`;

    const vp = viewport.getBoundingClientRect();
    const centerY = vp.top + vp.height * 0.5;
    let best = 0, bestDist = Infinity;
    posts.forEach((p, i) => {
      const r = p.getBoundingClientRect();
      const c = r.top + r.height * 0.5;
      const dist = Math.abs(c - centerY);
      if (dist < bestDist){ bestDist = dist; best = i; }
      const delta = (c - centerY) / vp.height;
      const clamp = Math.max(-1, Math.min(1, delta));
      p.style.setProperty("--par", clamp.toFixed(3));
      p.style.setProperty("--fade", (1 - Math.abs(clamp)).toFixed(3));
    });
    chip.textContent = posts[best].dataset.chip;
  }
  viewport.addEventListener("scroll", () => requestAnimationFrame(updateUI), { passive:true });
  window.addEventListener("resize", updateUI);
  updateUI();

  // --- CREATIVE AUTO SCROLL ENGINE ---
  const wait = (ms) => new Promise(r => setTimeout(r, ms));

  async function playSequence() {
    await wait(1000); // Μικρή παύση στην αρχή

    for (let i = 0; i < posts.length; i++) {
      const post = posts[i];

      // 1. Χρόνος ανάγνωσης (Wait)
      // Δίνουμε λίγο χρόνο στο χρήστη να διαβάσει
      const readingTime = parseInt(post.dataset.duration) || 4000;
      await wait(readingTime);

      // Αν είναι το τελευταίο ποστ, σταματάμε
      if (i === posts.length - 1) break;

      // 2. Εμφάνιση Χεριού (TAP)
      hand.classList.remove("active"); // Reset
      void hand.offsetWidth; // Force Reflow (Magic trick για να ξαναπαίξει το animation)
      hand.classList.add("active");
      
      // 3. Περιμένουμε το "Tap" να ολοκληρωθεί (περίπου 400ms)
      // Έτσι το σκρολ ξεκινάει ΜΑΖΙ με το σύρσιμο του χεριού
      await wait(450); 

      // 4. Πραγματικό Scroll (SWIPE)
      const nextPost = posts[i+1];
      viewport.scrollTo({
        top: nextPost.offsetTop - 20, // Μικρό offset για padding
        behavior: 'smooth'
      });

      // 5. Περιμένουμε να τελειώσει το animation του χεριού (1.5s συνολικά)
      // πριν πάμε στο επόμενο Loop
      await wait(1000);
    }
  }
  
  playSequence();

})();
</script>
